<!doctype html>
<html lang="en">\>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rhyming Pairs — MVP</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg:#0a1a12;
      --fg:#eef8f1;
      --muted:#b9d7c5;
      --accent:#7de0a2;
      --ok:#62d38a;
      --warn:#e7d36a;
      --bad:#ff8f8f;
      --panel:#10261c;
      --border:#1f3a2a;
      --field:#0e2118;
      --button:#173726;
      --pill:#0f2a1d;
    }
    html,body { margin:0; height:100%; font-family:"Fredoka One", system-ui, sans-serif; background:var(--bg) url("art/background.png") center/cover no-repeat fixed; color:var(--fg); }
    .wrap { max-width:900px; margin:0 auto; padding:24px; }
    header { display:flex; justify-content:space-between; align-items:center; gap:16px; }
    h1 { font-size:1.25rem; margin:0; color:var(--fg); }
    .timer { font-variant-numeric:tabular-nums; padding:8px 12px; border:1px solid var(--border); border-radius:10px; color:var(--accent); }
    .card { background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:16px; margin-top:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    /* Responsive image stage that adapts to any aspect ratio */
    .imgbox { 
      width:100%;
      min-height:220px;               /* keeps a nice stage on narrow screens */
      max-height:70vh;                /* never exceed 70% of viewport height */
      background:#0c1d14; 
      border:1px dashed var(--border); 
      border-radius:12px; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      overflow:hidden; 
      position:relative;
    }
    .imgbox::before{                  /* subtle checker to make transparency obvious */
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image: linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.04) 75%),
                        linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.04) 75%);
      background-size: 20px 20px; background-position: 0 0,10px 10px;
      border-radius:12px;
      z-index:0;
    }
    .imgbox img { 
      max-width:100%;
      max-height:100%;
      width:auto; height:auto;        /* natural size until constrained by the box */
      object-fit:contain;             /* no cropping; letterbox/pillarbox as needed */
      display:block;
      position:relative;
      z-index:1;
    }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    @media (max-width:560px){ .row{ grid-template-columns:1fr; } }
    input[type="text"] { width:100%; padding:12px 14px; border-radius:12px; border:1px solid var(--border); background:var(--field); color:var(--fg); font-family:"Fredoka One", system-ui, sans-serif; }
    input::placeholder { color:var(--muted); }
    .actions { display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
    button { padding:10px 14px; border-radius:12px; border:1px solid var(--border); background:var(--button); color:var(--fg); cursor:pointer; font-family:"Fredoka One", system-ui, sans-serif; }
    button:hover { filter:brightness(1.1); }
    .status { margin-top:8px; font-weight:600; }
    .status.ok { color:var(--ok); }
    .status.bad { color:var(--bad); }
    .small { color:var(--muted); font-size:.9rem; }
    .pill { display:inline-block; padding:3px 8px; border-radius:999px; background:var(--pill); border:1px solid var(--border); color:var(--muted); margin-left:6px; }
    .notice { margin-top:10px; color:var(--warn); font-weight:600; }
    .answer-input.match-ok { border-color:var(--ok); box-shadow:0 0 0 2px rgba(98,211,138,0.25); background:#123220; }
    .answer-input.match-root { border-color:var(--warn); box-shadow:0 0 0 2px rgba(231,211,106,0.25); background:#2a2a14; }
    .answer-input.match-bad { border-color:var(--bad); box-shadow:0 0 0 2px rgba(255,143,143,0.2); background:#2a1515; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Rhyming Pairs <span id="puzzleNum" class="pill"></span></h1>
      <div class="timer" id="timer">00:00.0</div>
    </header>

    <div class="card">
      <div class="imgbox">
        <img id="puzzleImg" alt="Puzzle image" />
      </div>
      <div id="availabilityNotice" class="notice" role="status" aria-live="polite"></div>

      <div class="row">
        <input id="pairA1" class="answer-input" type="text" placeholder="first phrase — word 1 (e.g., cracked)" autocomplete="off" />
        <input id="pairA2" class="answer-input" type="text" placeholder="first phrase — word 2 (e.g., stones)" autocomplete="off" />
      </div>
      <div class="row">
        <input id="pairB1" class="answer-input" type="text" placeholder="second phrase — word 1 (e.g., stacked)" autocomplete="off" />
        <input id="pairB2" class="answer-input" type="text" placeholder="second phrase — word 2 (e.g., crones)" autocomplete="off" />
      </div>

      <div class="actions">
        <button id="checkBtn">Check Answer</button>
        <button id="wordCheckBtn">Check Words (+60s)</button>
        <button id="skipBtn">Next Puzzle</button>
        <span class="small">Checking words adds +60s to your time.</span>
      </div>

      <div id="status" class="status"></div>
    </div>

    <div class="card small">
      <div><strong>How to win:</strong> Enter the two 2-word phrases that the image depicts (order doesn’t matter). Example target set: <code>cracked stones</code> + <code>stacked crones</code>.</div>
    </div>
  </div>

  <script>
    // --- Daily Puzzle from Supabase + Looser Answer Checking ---
    // Loads puzzles from Supabase via Netlify Functions and picks today's puzzle
    // by UTC date (falls back to most recent earlier puzzle).
    // Looser matching: word-order-insensitive (inside a phrase), plural-insensitive,
    // minor typos (Levenshtein <= 1), ignores hyphens/punctuation/case.

    // Simple schema guard
    function isPuzzle(obj){
      return obj && typeof obj.img==='string' && Array.isArray(obj.answers) && obj.answers.length===2 && obj.answers.every(ph => Array.isArray(ph) && ph.length===2) && Array.isArray(obj.hints);
    }

    function formatDateKey(date){
      const y = date.getUTCFullYear();
      const m = String(date.getUTCMonth()+1).padStart(2,'0');
      const d = String(date.getUTCDate()).padStart(2,'0');
      return `${y}-${m}-${d}`;
    }

    function formatShortMonth(date){
      return date.toLocaleDateString('en-US', { month: 'short', day: '2-digit', timeZone: 'UTC' });
    }

    // Fallback puzzles (used only if fetch fails)
    const FALLBACK = [
      {
        img: "https://images.unsplash.com/photo-1520974692280-5f4a1d1f0b9c?w=1200&q=80",
        answers: [["cracked","stones"],["stacked","crones"]],
        hints: [
          "Both phrases rhyme internally across pairs.",
          "Think stone fractures… and a coven doing gymnastics.",
          "One starts with C-R, the other with S-T."
        ]
      },
      {
        img: "https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=1200&q=80",
        answers: [["teal","sailor"],["seal","tailor"]],
        hints: [
          "Marine scene with measuring involved.",
          "One character wears pins; the other wears fins.",
          "Swap the starting consonants."
        ]
      }
    ];

    // --- State ---
    let PUZZLES = FALLBACK;
    let ix = 0;
    let startTs = 0;
    let tickHandle = null;
    let elapsedMs = 0;
    let penaltyMs = 0;
    let availabilityNotice = "";

    // Normalizer: lowercase, remove non-letters and apostrophes/hyphens
    const normalize = s => (s||"").toLowerCase().replace(/[^a-z]/g,"").trim();

    // Very small plural stemmer for common English plurals (best-effort, not perfect)
    function stem(w){
      if (!w) return w;
      if (w.endsWith('ies') && w.length>3) return w.slice(0,-3)+'y';           // stories -> story
      if (w.endsWith('ves') && w.length>3) return w.slice(0,-3)+'f';           // wolves -> wolf (knives->knif, acceptable for fuzzy)
      if (/(s|x|z|ch|sh)$/.test(w) && w.endsWith('es')) return w.slice(0,-2);  // boxes -> box, wishes -> wish
      if (w.endsWith('s') && w.length>3) return w.slice(0,-1);                 // stones -> stone
      return w;
    }

    // Levenshtein distance with early exit at >1
    function editDistanceLE1(a,b){
      const la=a.length, lb=b.length;
      if (a===b) return true;
      if (Math.abs(la-lb)>1) return false;
      // If same length, count mismatches allowing 0 or 1 substitution
      if (la===lb){
        let diff=0; for (let i=0;i<la;i++){ if (a[i]!==b[i] && ++diff>1) return false; }
        return true;
      }
      // Ensure a is shorter
      if (la>lb) return editDistanceLE1(b,a);
      // Now lb = la+1, allow one insertion in a (or deletion in b)
      let i=0,j=0,used=false;
      while(i<la && j<lb){
        if (a[i]===b[j]){ i++; j++; }
        else if (!used){ used=true; j++; }
        else return false;
      }
      return true; // any leftover is the one extra char
    }

    function wordsEqual(a,b){
      const na = normalize(a), nb = normalize(b);
      if (!na || !nb) return false;
      if (na===nb) return true;
      const sa = stem(na), sb = stem(nb);
      if (sa===sb) return true;
      if (editDistanceLE1(na,nb)) return true;
      if (editDistanceLE1(sa,sb)) return true;
      return false;
    }

    function matchStatus(typed, target){
      const nTyped = normalize(typed);
      const nTarget = normalize(target);
      if (!nTyped) return "match-bad";
      if (nTyped === nTarget) return "match-ok";
      const sTyped = stem(nTyped);
      const sTarget = stem(nTarget);
      if (sTyped && sTyped === sTarget) return "match-root";
      return "match-bad";
    }

    function applyMatchClasses(statuses){
      const inputs = [$a1, $a2, $b1, $b2];
      inputs.forEach((input, index) => {
        input.classList.remove("match-ok", "match-root", "match-bad");
        if (statuses[index]) {
          input.classList.add(statuses[index]);
        }
      });
    }

    function evaluateArrangement(targetAnswers){
      const inputs = [$a1.value, $a2.value, $b1.value, $b2.value];
      const targets = [targetAnswers[0][0], targetAnswers[0][1], targetAnswers[1][0], targetAnswers[1][1]];
      const statuses = inputs.map((value, idx) => matchStatus(value, targets[idx]));
      const score = statuses.reduce((total, status) => {
        if (status === "match-ok") return total + 2;
        if (status === "match-root") return total + 1;
        return total;
      }, 0);
      return { statuses, score };
    }

    function expandTargetArrangements(answers){
      const [phraseA, phraseB] = answers;
      const variants = [];
      const orders = [
        [phraseA, phraseB],
        [phraseB, phraseA]
      ];
      orders.forEach(([first, second]) => {
        const firstOrders = [
          [first[0], first[1]],
          [first[1], first[0]]
        ];
        const secondOrders = [
          [second[0], second[1]],
          [second[1], second[0]]
        ];
        firstOrders.forEach((firstPhrase) => {
          secondOrders.forEach((secondPhrase) => {
            variants.push([firstPhrase, secondPhrase]);
          });
        });
      });
      return variants;
    }

    // Two-word phrase equality, order-insensitive within the phrase
    function phraseEqual(typed, target){
      const [ta,tb] = typed; const [ua,ub] = target;
      // direct order
      if (wordsEqual(ta,ua) && wordsEqual(tb,ub)) return true;
      // swapped order
      if (wordsEqual(ta,ub) && wordsEqual(tb,ua)) return true;
      return false;
    }

    // Elements
    const $img = document.getElementById("puzzleImg");
    const $timer = document.getElementById("timer");
    const $status = document.getElementById("status");
    const $num = document.getElementById("puzzleNum");
    const $notice = document.getElementById("availabilityNotice");
    const $a1 = document.getElementById("pairA1");
    const $a2 = document.getElementById("pairA2");
    const $b1 = document.getElementById("pairB1");
    const $b2 = document.getElementById("pairB2");
    const $check = document.getElementById("checkBtn");
    const $wordCheck = document.getElementById("wordCheckBtn");
    const $skip = document.getElementById("skipBtn");

    function setStatus(msg,cls){ $status.textContent = msg; $status.className = `status ${cls||''}`; }
    function setNotice(msg){ $notice.textContent = msg; }

    function disableUI(disabled=true){
      [$a1,$a2,$b1,$b2,$check,$wordCheck,$skip].forEach(el=> el.disabled = disabled);
    }

    function startTimer() {
      stopTimer();
      startTs = performance.now();
      tickHandle = setInterval(() => {
        elapsedMs = performance.now() - startTs + penaltyMs;
        $timer.textContent = formatMs(elapsedMs);
      }, 100);
    }
    function stopTimer() { if (tickHandle) { clearInterval(tickHandle); tickHandle = null; } }
    function formatMs(ms) {
      const t = Math.floor(ms);
      const m = Math.floor(t/60000);
      const s = Math.floor((t%60000)/1000);
      const d = Math.floor((t%1000)/100);
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${d}`;
    }

    function phrasesFromInputs() {
      const p1 = [($a1.value||''), ($a2.value||'')];
      const p2 = [($b1.value||''), ($b2.value||'')];
      if (!p1[0].trim() || !p1[1].trim() || !p2[0].trim() || !p2[1].trim()) return null;
      return [p1, p2];
    }

    function checkAnswer() {
      const p = PUZZLES[ix];
      const typed = phrasesFromInputs();
      if (!typed) { setStatus("Please fill out all four words.", "bad"); return; }
      const [t1,t2] = typed; const A = p.answers;
      const ok = (phraseEqual(t1,A[0]) && phraseEqual(t2,A[1])) || (phraseEqual(t1,A[1]) && phraseEqual(t2,A[0]));
      if (ok) { stopTimer(); setStatus(`Correct! Time: ${formatMs(elapsedMs)} — Great job.`, "ok"); }
      else { setStatus("Not quite—keep trying!", "bad"); }
    }

    function checkWords() {
      const p = PUZZLES[ix];
      const candidates = expandTargetArrangements(p.answers).map((target) => evaluateArrangement(target));
      const best = candidates.reduce((currentBest, candidate) => (
        candidate.score > currentBest.score ? candidate : currentBest
      ), candidates[0]);
      applyMatchClasses(best.statuses);
      penaltyMs += 60000;
      elapsedMs = performance.now() - startTs + penaltyMs;
      $timer.textContent = formatMs(elapsedMs);
      setStatus("Word check applied (+60s).", "");
    }

    function loadPuzzleByIndex(index){
      ix = index;
      const p = PUZZLES[ix];
      $num.textContent = `#${ix+1}/${PUZZLES.length}`;
      [$a1,$a2,$b1,$b2].forEach(el => el.value = "");
      $status.textContent = ""; $status.className = "status"; penaltyMs = 0;
      applyMatchClasses([]);
      setNotice(availabilityNotice);
      disableUI(true);
      const img = new Image();
      img.onload = () => {
        // Dynamically size container height to preserve big/tall images nicely
        const naturalAR = img.naturalWidth / img.naturalHeight;
        const wrap = document.querySelector('.wrap');
        const stage = document.querySelector('.imgbox');
        const maxW = wrap.getBoundingClientRect().width - 2; // minus borders
        const maxH = Math.min(window.innerHeight * 0.7, 800); // cap huge desktops
        // Compute fit like CSS contain but we also set an explicit stage height for stable layout
        let targetH = maxW / naturalAR;        // height if constrained by width
        if (targetH > maxH) targetH = maxH;    // constrain overly tall images
        stage.style.height = targetH + 'px';
        $img.src = p.img; 
        disableUI(false); 
        $a1.focus(); 
        startTimer(); 
      };
      img.onerror = () => { 
        const stage = document.querySelector('.imgbox');
        stage.style.height = 'auto';
        setStatus("Image failed to load. Check the path in puzzles.json.", "bad"); 
        disableUI(false); 
      };
      img.src = p.img;
    }

    function nextPuzzle() { loadPuzzleByIndex((ix + 1) % PUZZLES.length); }

    async function loadConfig(){
      const res = await fetch('/.netlify/functions/get-config');
      if (!res.ok) throw new Error('Missing Supabase config.');
      return res.json();
    }

    async function loadPuzzlesFromSupabase(){
      const res = await fetch('/.netlify/functions/list-puzzles', { cache: 'no-store' });
      if (!res.ok) throw new Error(`Supabase load error: ${res.status}`);
      const data = await res.json();
      if (!data || !Array.isArray(data.puzzles)) throw new Error('Unexpected puzzles response');
      const parsed = data.puzzles.map((puzzle) => {
        const date = new Date(puzzle.publish_at);
        return {
          img: puzzle.img,
          answers: puzzle.answers,
          hints: puzzle.hints || [],
          date,
          dateKey: formatDateKey(date),
          displayDate: formatShortMonth(date)
        };
      }).filter(p => !Number.isNaN(p.date.getTime()));
      if (parsed.length === 0) throw new Error('No valid puzzles found');
      return parsed.sort((a,b) => a.date - b.date);
    }

    function selectPuzzleForToday(puzzles){
      const todayKey = formatDateKey(new Date());
      const todayIndex = puzzles.findIndex(p => p.dateKey === todayKey);
      if (todayIndex >= 0) {
        availabilityNotice = "";
        return todayIndex;
      }
      const prior = puzzles.filter(p => p.dateKey < todayKey);
      if (prior.length > 0) {
        const latest = prior[prior.length - 1];
        availabilityNotice = "Sorry, today\u2019s image is unavailable, here is the most recent puzzle.";
        return puzzles.indexOf(latest);
      }
      const earliest = puzzles[0];
      availabilityNotice = "Sorry, today\u2019s image is unavailable, here is the most recent puzzle.";
      return 0;
    }

    function applyFallbackDates(puzzles){
      const now = new Date();
      const y = now.getUTCFullYear();
      const m = now.getUTCMonth();
      const d = now.getUTCDate();
      return puzzles.map((p, index) => {
        const date = new Date(Date.UTC(y, m, d - index));
        return {
          ...p,
          date,
          dateKey: formatDateKey(date),
          displayDate: formatShortMonth(date)
        };
      });
    }

    async function boot(){
      disableUI(true);
      setStatus("Loading today\'s puzzle…", "");
      try {
        await loadConfig();
        PUZZLES = await loadPuzzlesFromSupabase();
      } catch (e){
        console.warn('Using fallback puzzles because Supabase load failed:', e);
        setStatus("Using fallback puzzles (couldn’t load Supabase puzzles).", "");
        PUZZLES = applyFallbackDates(FALLBACK);
      }
      const idx = selectPuzzleForToday(PUZZLES);
      loadPuzzleByIndex(idx);
    }

    // Events
    $check.addEventListener("click", checkAnswer);
    $wordCheck.addEventListener("click", checkWords);
    $skip.addEventListener("click", nextPuzzle);
    [$a1,$a2,$b1,$b2].forEach(el => el.addEventListener("keydown", e => { if (e.key === "Enter") checkAnswer(); }));

    // Start
    window.addEventListener('resize', () => {
      // Recompute stage height on resize for current image
      const p = PUZZLES[ix];
      if (!$img.src) return;
      const img = new Image();
      img.onload = () => {
        const naturalAR = img.naturalWidth / img.naturalHeight;
        const wrap = document.querySelector('.wrap');
        const stage = document.querySelector('.imgbox');
        const maxW = wrap.getBoundingClientRect().width - 2;
        const maxH = Math.min(window.innerHeight * 0.7, 800);
        let targetH = maxW / naturalAR;
        if (targetH > maxH) targetH = maxH;
        stage.style.height = targetH + 'px';
      };
      img.src = p.img;
    });
    boot();
  </script>
</body>
</html>
