<!doctype html>
<html lang="en">\>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rhyming Pairs — MVP</title>
  <style>
    :root { --bg:#0f1221; --fg:#e9ecf1; --muted:#aab0c0; --accent:#7bd3ff; --ok:#78e08f; --bad:#ff7675; }
    html,body { margin:0; height:100%; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--fg); }
    .wrap { max-width:900px; margin:0 auto; padding:24px; }
    header { display:flex; justify-content:space-between; align-items:center; gap:16px; }
    h1 { font-size:1.25rem; margin:0; color:var(--fg); }
    .timer { font-variant-numeric:tabular-nums; padding:8px 12px; border:1px solid #2a2f49; border-radius:10px; color:var(--accent); }
    .card { background:#151935; border:1px solid #2a2f49; border-radius:16px; padding:16px; margin-top:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    /* Responsive image stage that adapts to any aspect ratio */
    .imgbox { 
      width:100%;
      min-height:220px;               /* keeps a nice stage on narrow screens */
      max-height:70vh;                /* never exceed 70% of viewport height */
      background:#0a0d1f; 
      border:1px dashed #2a2f49; 
      border-radius:12px; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      overflow:hidden; 
      position:relative;
    }
    .imgbox::before{                  /* subtle checker to make transparency obvious */
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image: linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.04) 75%),
                        linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.04) 75%);
      background-size: 20px 20px; background-position: 0 0,10px 10px;
      border-radius:12px;
    }
    .imgbox img { 
      max-width:100%;
      max-height:100%;
      width:auto; height:auto;        /* natural size until constrained by the box */
      object-fit:contain;             /* no cropping; letterbox/pillarbox as needed */
      display:block;
    }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    @media (max-width:560px){ .row{ grid-template-columns:1fr; } }
    input[type="text"] { width:100%; padding:12px 14px; border-radius:12px; border:1px solid #2a2f49; background:#0f1330; color:var(--fg); }
    input::placeholder { color:var(--muted); }
    .actions { display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
    button { padding:10px 14px; border-radius:12px; border:1px solid #2a2f49; background:#1a1f44; color:var(--fg); cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    .hint { color:var(--muted); margin-top:8px; min-height:1.4em; }
    .status { margin-top:8px; font-weight:600; }
    .status.ok { color:var(--ok); }
    .status.bad { color:var(--bad); }
    .small { color:var(--muted); font-size:.9rem; }
    .pill { display:inline-block; padding:3px 8px; border-radius:999px; background:#101537; border:1px solid #2a2f49; color:var(--muted); margin-left:6px; }
    .notice { margin-top:10px; color:#ffd36e; font-weight:600; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Rhyming Pairs <span id="puzzleNum" class="pill"></span></h1>
      <div class="timer" id="timer">00:00.0</div>
    </header>

    <div class="card">
      <div class="imgbox">
        <img id="puzzleImg" alt="Puzzle image" />
      </div>
      <div id="availabilityNotice" class="notice" role="status" aria-live="polite"></div>

      <div class="row">
        <input id="pairA1" type="text" placeholder="first phrase — word 1 (e.g., cracked)" autocomplete="off" />
        <input id="pairA2" type="text" placeholder="first phrase — word 2 (e.g., stones)" autocomplete="off" />
      </div>
      <div class="row">
        <input id="pairB1" type="text" placeholder="second phrase — word 1 (e.g., stacked)" autocomplete="off" />
        <input id="pairB2" type="text" placeholder="second phrase — word 2 (e.g., crones)" autocomplete="off" />
      </div>

      <div class="actions">
        <button id="checkBtn">Check Answer</button>
        <button id="hintBtn">Hint</button>
        <button id="skipBtn">Next Puzzle</button>
        <span class="small">Hints add +10s to your time.</span>
      </div>

      <div id="hint" class="hint"></div>
      <div id="status" class="status"></div>
    </div>

    <div class="card small">
      <div><strong>How to win:</strong> Enter the two 2-word phrases that the image depicts (order doesn’t matter). Example target set: <code>cracked stones</code> + <code>stacked crones</code>.</div>
    </div>
  </div>

  <script>
    // --- Daily Puzzle from Filenames + Looser Answer Checking ---
    // Loads /puzzles directory contents from GitHub, derives answers from filenames,
    // and picks today's puzzle by UTC date (falls back to most recent earlier puzzle).
    // Looser matching: word-order-insensitive (inside a phrase), plural-insensitive,
    // minor typos (Levenshtein <= 1), ignores hyphens/punctuation/case.

    // Simple schema guard
    function isPuzzle(obj){
      return obj && typeof obj.img==='string' && Array.isArray(obj.answers) && obj.answers.length===2 && obj.answers.every(ph => Array.isArray(ph) && ph.length===2) && Array.isArray(obj.hints);
    }

    function formatDateKey(date){
      const y = date.getUTCFullYear();
      const m = String(date.getUTCMonth()+1).padStart(2,'0');
      const d = String(date.getUTCDate()).padStart(2,'0');
      return `${y}-${m}-${d}`;
    }

    function formatShortMonth(date){
      return date.toLocaleDateString('en-US', { month: 'short', day: '2-digit', timeZone: 'UTC' });
    }

    // Fallback puzzles (used only if fetch fails)
    const FALLBACK = [
      {
        img: "https://images.unsplash.com/photo-1520974692280-5f4a1d1f0b9c?w=1200&q=80",
        answers: [["cracked","stones"],["stacked","crones"]],
        hints: [
          "Both phrases rhyme internally across pairs.",
          "Think stone fractures… and a coven doing gymnastics.",
          "One starts with C-R, the other with S-T."
        ]
      },
      {
        img: "https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=1200&q=80",
        answers: [["teal","sailor"],["seal","tailor"]],
        hints: [
          "Marine scene with measuring involved.",
          "One character wears pins; the other wears fins.",
          "Swap the starting consonants."
        ]
      }
    ];

    // --- State ---
    let PUZZLES = FALLBACK;
    let ix = 0;
    let startTs = 0;
    let tickHandle = null;
    let elapsedMs = 0;
    let penaltyMs = 0;
    let availabilityNotice = "";

    // Normalizer: lowercase, remove non-letters and apostrophes/hyphens
    const normalize = s => (s||"").toLowerCase().replace(/[^a-z]/g,"").trim();

    // Very small plural stemmer for common English plurals (best-effort, not perfect)
    function stem(w){
      if (!w) return w;
      if (w.endsWith('ies') && w.length>3) return w.slice(0,-3)+'y';           // stories -> story
      if (w.endsWith('ves') && w.length>3) return w.slice(0,-3)+'f';           // wolves -> wolf (knives->knif, acceptable for fuzzy)
      if (/(s|x|z|ch|sh)$/.test(w) && w.endsWith('es')) return w.slice(0,-2);  // boxes -> box, wishes -> wish
      if (w.endsWith('s') && w.length>3) return w.slice(0,-1);                 // stones -> stone
      return w;
    }

    // Levenshtein distance with early exit at >1
    function editDistanceLE1(a,b){
      const la=a.length, lb=b.length;
      if (a===b) return true;
      if (Math.abs(la-lb)>1) return false;
      // If same length, count mismatches allowing 0 or 1 substitution
      if (la===lb){
        let diff=0; for (let i=0;i<la;i++){ if (a[i]!==b[i] && ++diff>1) return false; }
        return true;
      }
      // Ensure a is shorter
      if (la>lb) return editDistanceLE1(b,a);
      // Now lb = la+1, allow one insertion in a (or deletion in b)
      let i=0,j=0,used=false;
      while(i<la && j<lb){
        if (a[i]===b[j]){ i++; j++; }
        else if (!used){ used=true; j++; }
        else return false;
      }
      return true; // any leftover is the one extra char
    }

    function wordsEqual(a,b){
      const na = normalize(a), nb = normalize(b);
      if (!na || !nb) return false;
      if (na===nb) return true;
      const sa = stem(na), sb = stem(nb);
      if (sa===sb) return true;
      if (editDistanceLE1(na,nb)) return true;
      if (editDistanceLE1(sa,sb)) return true;
      return false;
    }

    // Two-word phrase equality, order-insensitive within the phrase
    function phraseEqual(typed, target){
      const [ta,tb] = typed; const [ua,ub] = target;
      // direct order
      if (wordsEqual(ta,ua) && wordsEqual(tb,ub)) return true;
      // swapped order
      if (wordsEqual(ta,ub) && wordsEqual(tb,ua)) return true;
      return false;
    }

    // Elements
    const $img = document.getElementById("puzzleImg");
    const $timer = document.getElementById("timer");
    const $status = document.getElementById("status");
    const $hint = document.getElementById("hint");
    const $num = document.getElementById("puzzleNum");
    const $notice = document.getElementById("availabilityNotice");
    const $a1 = document.getElementById("pairA1");
    const $a2 = document.getElementById("pairA2");
    const $b1 = document.getElementById("pairB1");
    const $b2 = document.getElementById("pairB2");
    const $check = document.getElementById("checkBtn");
    const $hintBtn = document.getElementById("hintBtn");
    const $skip = document.getElementById("skipBtn");

    function setStatus(msg,cls){ $status.textContent = msg; $status.className = `status ${cls||''}`; }
    function setNotice(msg){ $notice.textContent = msg; }

    function disableUI(disabled=true){
      [$a1,$a2,$b1,$b2,$check,$hintBtn,$skip].forEach(el=> el.disabled = disabled);
    }

    function startTimer() {
      stopTimer();
      startTs = performance.now();
      tickHandle = setInterval(() => {
        elapsedMs = performance.now() - startTs + penaltyMs;
        $timer.textContent = formatMs(elapsedMs);
      }, 100);
    }
    function stopTimer() { if (tickHandle) { clearInterval(tickHandle); tickHandle = null; } }
    function formatMs(ms) {
      const t = Math.floor(ms);
      const m = Math.floor(t/60000);
      const s = Math.floor((t%60000)/1000);
      const d = Math.floor((t%1000)/100);
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${d}`;
    }

    function phrasesFromInputs() {
      const p1 = [($a1.value||''), ($a2.value||'')];
      const p2 = [($b1.value||''), ($b2.value||'')];
      if (!p1[0].trim() || !p1[1].trim() || !p2[0].trim() || !p2[1].trim()) return null;
      return [p1, p2];
    }

    function checkAnswer() {
      const p = PUZZLES[ix];
      const typed = phrasesFromInputs();
      if (!typed) { setStatus("Please fill out all four words.", "bad"); return; }
      const [t1,t2] = typed; const A = p.answers;
      const ok = (phraseEqual(t1,A[0]) && phraseEqual(t2,A[1])) || (phraseEqual(t1,A[1]) && phraseEqual(t2,A[0]));
      if (ok) { stopTimer(); setStatus(`Correct! Time: ${formatMs(elapsedMs)} — Great job.`, "ok"); }
      else { setStatus("Not quite—keep trying!", "bad"); }
    }

    function useHint() {
      const p = PUZZLES[ix];
      const shown = $hint.dataset.n ? parseInt($hint.dataset.n,10) : 0;
      if (shown < p.hints.length) {
        $hint.textContent = p.hints.slice(0, shown+1).join("  •  ");
        $hint.dataset.n = String(shown+1);
        penaltyMs += 10000; // +10s per hint
      } else {
        $hint.textContent = p.hints.length ? "No more hints." : "No hints available.";
      }
    }

    function loadPuzzleByIndex(index){
      ix = index;
      const p = PUZZLES[ix];
      $num.textContent = `#${ix+1}/${PUZZLES.length}`;
      [$a1,$a2,$b1,$b2].forEach(el => el.value = "");
      $status.textContent = ""; $status.className = "status"; $hint.textContent = ""; $hint.dataset.n = "0"; penaltyMs = 0;
      setNotice(availabilityNotice);
      disableUI(true);
      const img = new Image();
      img.onload = () => {
        // Dynamically size container height to preserve big/tall images nicely
        const naturalAR = img.naturalWidth / img.naturalHeight;
        const wrap = document.querySelector('.wrap');
        const stage = document.querySelector('.imgbox');
        const maxW = wrap.getBoundingClientRect().width - 2; // minus borders
        const maxH = Math.min(window.innerHeight * 0.7, 800); // cap huge desktops
        // Compute fit like CSS contain but we also set an explicit stage height for stable layout
        let targetH = maxW / naturalAR;        // height if constrained by width
        if (targetH > maxH) targetH = maxH;    // constrain overly tall images
        stage.style.height = targetH + 'px';
        $img.src = p.img; 
        disableUI(false); 
        $a1.focus(); 
        startTimer(); 
      };
      img.onerror = () => { 
        const stage = document.querySelector('.imgbox');
        stage.style.height = 'auto';
        setStatus("Image failed to load. Check the path in puzzles.json.", "bad"); 
        disableUI(false); 
      };
      img.src = p.img;
    }

    function nextPuzzle() { loadPuzzleByIndex((ix + 1) % PUZZLES.length); }

    function splitWords(text){
      const cleaned = text.replace(/[^A-Za-z]/g, ' ');
      const parts = cleaned.match(/[A-Z]+(?![a-z])|[A-Z]?[a-z]+/g) || [];
      return parts.map(word => word.toLowerCase());
    }

    function parsePuzzleFromFilename(filename){
      const base = filename.replace(/\.[^.]+$/, '');
      const match = base.match(/^(\d{1,2})([a-z]{3})(\d{4})_(.+)$/i);
      if (!match) return null;
      const [, dayRaw, monRaw, yearRaw, phraseRaw] = match;
      const monthIndex = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'].indexOf(monRaw.toLowerCase());
      if (monthIndex === -1) return null;
      const date = new Date(Date.UTC(parseInt(yearRaw,10), monthIndex, parseInt(dayRaw,10)));
      if (Number.isNaN(date.getTime())) return null;
      const words = splitWords(phraseRaw);
      if (words.length < 4) return null;
      const answers = [
        [words[0], words[1]],
        [words[2], words[3]]
      ];
      return {
        date,
        dateKey: formatDateKey(date),
        displayDate: formatShortMonth(date),
        answers,
        hints: [],
        filename
      };
    }

    function resolveRepository(){
      const host = window.location.hostname;
      const pathname = window.location.pathname.replace(/^\/+/, '');
      const firstSegment = pathname.split('/')[0];
      if (host.endsWith('github.io')) {
        const owner = host.split('.')[0];
        const repo = firstSegment ? firstSegment : `${owner}.github.io`;
        return { owner, repo, branch: 'main' };
      }
      return null;
    }

    async function loadPuzzlesFromGithub(){
      const repo = resolveRepository();
      if (!repo) throw new Error('Unable to infer GitHub repository from URL.');
      const apiUrl = `https://api.github.com/repos/${repo.owner}/${repo.repo}/contents/puzzles?ref=${repo.branch}`;
      const res = await fetch(apiUrl, { cache: 'no-store' });
      if (!res.ok) throw new Error(`GitHub API error: ${res.status}`);
      const data = await res.json();
      if (!Array.isArray(data)) throw new Error('Unexpected GitHub API response');
      const imageFiles = data.filter(item => item.type === 'file' && /\.(png|jpe?g|bmp|gif|webp)$/i.test(item.name));
      const parsed = imageFiles.map(item => parsePuzzleFromFilename(item.name))
        .filter(Boolean)
        .map(puzzle => ({
          ...puzzle,
          img: `./puzzles/${puzzle.filename}`
        }));
      if (parsed.length === 0) throw new Error('No valid puzzle images found');
      return parsed.sort((a,b) => a.date - b.date);
    }

    function selectPuzzleForToday(puzzles){
      const todayKey = formatDateKey(new Date());
      const todayIndex = puzzles.findIndex(p => p.dateKey === todayKey);
      if (todayIndex >= 0) {
        availabilityNotice = "";
        return todayIndex;
      }
      const prior = puzzles.filter(p => p.dateKey < todayKey);
      if (prior.length > 0) {
        const latest = prior[prior.length - 1];
        availabilityNotice = `Sorry, today\u2019s image is unavailable, here is one from ${latest.displayDate}.`;
        return puzzles.indexOf(latest);
      }
      const earliest = puzzles[0];
      availabilityNotice = `Sorry, today\u2019s image is unavailable, here is one from ${earliest.displayDate}.`;
      return 0;
    }

    function applyFallbackDates(puzzles){
      const now = new Date();
      const y = now.getUTCFullYear();
      const m = now.getUTCMonth();
      const d = now.getUTCDate();
      return puzzles.map((p, index) => {
        const date = new Date(Date.UTC(y, m, d - index));
        return {
          ...p,
          date,
          dateKey: formatDateKey(date),
          displayDate: formatShortMonth(date)
        };
      });
    }

    async function boot(){
      disableUI(true);
      setStatus("Loading today\'s puzzle…", "");
      try {
        PUZZLES = await loadPuzzlesFromGithub();
      } catch (e){
        console.warn('Using fallback puzzles because GitHub load failed:', e);
        setStatus("Using fallback puzzles (couldn’t load GitHub images).", "");
        PUZZLES = applyFallbackDates(FALLBACK);
      }
      const idx = selectPuzzleForToday(PUZZLES);
      loadPuzzleByIndex(idx);
    }

    // Events
    $check.addEventListener("click", checkAnswer);
    $hintBtn.addEventListener("click", useHint);
    $skip.addEventListener("click", nextPuzzle);
    [$a1,$a2,$b1,$b2].forEach(el => el.addEventListener("keydown", e => { if (e.key === "Enter") checkAnswer(); }));

    // Start
    window.addEventListener('resize', () => {
      // Recompute stage height on resize for current image
      const p = PUZZLES[ix];
      if (!$img.src) return;
      const img = new Image();
      img.onload = () => {
        const naturalAR = img.naturalWidth / img.naturalHeight;
        const wrap = document.querySelector('.wrap');
        const stage = document.querySelector('.imgbox');
        const maxW = wrap.getBoundingClientRect().width - 2;
        const maxH = Math.min(window.innerHeight * 0.7, 800);
        let targetH = maxW / naturalAR;
        if (targetH > maxH) targetH = maxH;
        stage.style.height = targetH + 'px';
      };
      img.src = p.img;
    });
    boot();
  </script>
</body>
</html>
