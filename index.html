<!doctype html>
<html lang="en">\>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rhyming Pairs — MVP</title>
  <style>
    :root { --bg:#0f1221; --fg:#e9ecf1; --muted:#aab0c0; --accent:#7bd3ff; --ok:#78e08f; --bad:#ff7675; }
    html,body { margin:0; height:100%; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--fg); }
    .wrap { max-width:900px; margin:0 auto; padding:24px; }
    header { display:flex; justify-content:space-between; align-items:center; gap:16px; }
    h1 { font-size:1.25rem; margin:0; color:var(--fg); }
    .timer { font-variant-numeric:tabular-nums; padding:8px 12px; border:1px solid #2a2f49; border-radius:10px; color:var(--accent); }
    .card { background:#151935; border:1px solid #2a2f49; border-radius:16px; padding:16px; margin-top:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    /* Responsive image stage that adapts to any aspect ratio */
    .imgbox { 
      width:100%;
      min-height:220px;               /* keeps a nice stage on narrow screens */
      max-height:70vh;                /* never exceed 70% of viewport height */
      background:#0a0d1f; 
      border:1px dashed #2a2f49; 
      border-radius:12px; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      overflow:hidden; 
      position:relative;
    }
    .imgbox::before{                  /* subtle checker to make transparency obvious */
      content:""; position:absolute; inset:0; pointer-events:none;
      background-image: linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.04) 75%),
                        linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.04) 75%);
      background-size: 20px 20px; background-position: 0 0,10px 10px;
      border-radius:12px;
    }
    .imgbox img { 
      max-width:100%;
      max-height:100%;
      width:auto; height:auto;        /* natural size until constrained by the box */
      object-fit:contain;             /* no cropping; letterbox/pillarbox as needed */
      display:block;
    }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    @media (max-width:560px){ .row{ grid-template-columns:1fr; } }
    input[type="text"] { width:100%; padding:12px 14px; border-radius:12px; border:1px solid #2a2f49; background:#0f1330; color:var(--fg); }
    input::placeholder { color:var(--muted); }
    .actions { display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
    button { padding:10px 14px; border-radius:12px; border:1px solid #2a2f49; background:#1a1f44; color:var(--fg); cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    .hint { color:var(--muted); margin-top:8px; min-height:1.4em; }
    .status { margin-top:8px; font-weight:600; }
    .status.ok { color:var(--ok); }
    .status.bad { color:var(--bad); }
    .small { color:var(--muted); font-size:.9rem; }
    .pill { display:inline-block; padding:3px 8px; border-radius:999px; background:#101537; border:1px solid #2a2f49; color:var(--muted); margin-left:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Rhyming Pairs <span id="puzzleNum" class="pill"></span></h1>
      <div class="timer" id="timer">00:00.0</div>
    </header>

    <div class="card">
      <div class="imgbox">
        <img id="puzzleImg" alt="Puzzle image" />
      </div>

      <div class="row">
        <input id="pairA1" type="text" placeholder="first phrase — word 1 (e.g., cracked)" autocomplete="off" />
        <input id="pairA2" type="text" placeholder="first phrase — word 2 (e.g., stones)" autocomplete="off" />
      </div>
      <div class="row">
        <input id="pairB1" type="text" placeholder="second phrase — word 1 (e.g., stacked)" autocomplete="off" />
        <input id="pairB2" type="text" placeholder="second phrase — word 2 (e.g., crones)" autocomplete="off" />
      </div>

      <div class="actions">
        <button id="checkBtn">Check Answer</button>
        <button id="hintBtn">Hint</button>
        <button id="skipBtn">Next Puzzle</button>
        <span class="small">Hints add +10s to your time.</span>
      </div>

      <div id="hint" class="hint"></div>
      <div id="status" class="status"></div>
    </div>

    <div class="card small">
      <div><strong>How to win:</strong> Enter the two 2-word phrases that the image depicts (order doesn’t matter). Example target set: <code>cracked stones</code> + <code>stacked crones</code>.</div>
    </div>
  </div>

  <script>
    // --- Daily Puzzle + External JSON Loader + Looser Answer Checking ---
    // Loads /puzzles.json at runtime and picks today by UTC date.
    // Looser matching: word-order-insensitive (inside a phrase), plural-insensitive,
    // minor typos (Levenshtein <= 1), ignores hyphens/punctuation/case.

    // Simple schema guard
    function isPuzzle(obj){
      return obj && typeof obj.img==='string' && Array.isArray(obj.answers) && obj.answers.length===2 && obj.answers.every(ph => Array.isArray(ph) && ph.length===2) && Array.isArray(obj.hints);
    }

    // Deterministic daily selector by UTC date (YYYY-MM-DD)
    function selectDailyIndex(len, date=new Date()){
      const y = date.getUTCFullYear();
      const m = String(date.getUTCMonth()+1).padStart(2,'0');
      const d = String(date.getUTCDate()).padStart(2,'0');
      const key = `${y}-${m}-${d}`;
      let h=0; for (let i=0;i<key.length;i++){ h = (h*31 + key.charCodeAt(i)) >>> 0; }
      return h % len;
    }

    // Fallback puzzles (used only if fetch fails)
    const FALLBACK = [
      {
        img: "https://images.unsplash.com/photo-1520974692280-5f4a1d1f0b9c?w=1200&q=80",
        answers: [["cracked","stones"],["stacked","crones"]],
        hints: [
          "Both phrases rhyme internally across pairs.",
          "Think stone fractures… and a coven doing gymnastics.",
          "One starts with C-R, the other with S-T."
        ]
      },
      {
        img: "https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=1200&q=80",
        answers: [["teal","sailor"],["seal","tailor"]],
        hints: [
          "Marine scene with measuring involved.",
          "One character wears pins; the other wears fins.",
          "Swap the starting consonants."
        ]
      }
    ];

    // --- State ---
    let PUZZLES = FALLBACK;
    let ix = 0;
    let startTs = 0;
    let tickHandle = null;
    let elapsedMs = 0;
    let penaltyMs = 0;

    // Normalizer: lowercase, remove non-letters and apostrophes/hyphens
    const normalize = s => (s||"").toLowerCase().replace(/[^a-z]/g,"").trim();

    // Very small plural stemmer for common English plurals (best-effort, not perfect)
    function stem(w){
      if (!w) return w;
      if (w.endsWith('ies') && w.length>3) return w.slice(0,-3)+'y';           // stories -> story
      if (w.endsWith('ves') && w.length>3) return w.slice(0,-3)+'f';           // wolves -> wolf (knives->knif, acceptable for fuzzy)
      if (/(s|x|z|ch|sh)$/.test(w) && w.endsWith('es')) return w.slice(0,-2);  // boxes -> box, wishes -> wish
      if (w.endsWith('s') && w.length>3) return w.slice(0,-1);                 // stones -> stone
      return w;
    }

    // Levenshtein distance with early exit at >1
    function editDistanceLE1(a,b){
      const la=a.length, lb=b.length;
      if (a===b) return true;
      if (Math.abs(la-lb)>1) return false;
      // If same length, count mismatches allowing 0 or 1 substitution
      if (la===lb){
        let diff=0; for (let i=0;i<la;i++){ if (a[i]!==b[i] && ++diff>1) return false; }
        return true;
      }
      // Ensure a is shorter
      if (la>lb) return editDistanceLE1(b,a);
      // Now lb = la+1, allow one insertion in a (or deletion in b)
      let i=0,j=0,used=false;
      while(i<la && j<lb){
        if (a[i]===b[j]){ i++; j++; }
        else if (!used){ used=true; j++; }
        else return false;
      }
      return true; // any leftover is the one extra char
    }

    function wordsEqual(a,b){
      const na = normalize(a), nb = normalize(b);
      if (!na || !nb) return false;
      if (na===nb) return true;
      const sa = stem(na), sb = stem(nb);
      if (sa===sb) return true;
      if (editDistanceLE1(na,nb)) return true;
      if (editDistanceLE1(sa,sb)) return true;
      return false;
    }

    // Two-word phrase equality, order-insensitive within the phrase
    function phraseEqual(typed, target){
      const [ta,tb] = typed; const [ua,ub] = target;
      // direct order
      if (wordsEqual(ta,ua) && wordsEqual(tb,ub)) return true;
      // swapped order
      if (wordsEqual(ta,ub) && wordsEqual(tb,ua)) return true;
      return false;
    }

    // Elements
    const $img = document.getElementById("puzzleImg");
    const $timer = document.getElementById("timer");
    const $status = document.getElementById("status");
    const $hint = document.getElementById("hint");
    const $num = document.getElementById("puzzleNum");
    const $a1 = document.getElementById("pairA1");
    const $a2 = document.getElementById("pairA2");
    const $b1 = document.getElementById("pairB1");
    const $b2 = document.getElementById("pairB2");
    const $check = document.getElementById("checkBtn");
    const $hintBtn = document.getElementById("hintBtn");
    const $skip = document.getElementById("skipBtn");

    function setStatus(msg,cls){ $status.textContent = msg; $status.className = `status ${cls||''}`; }

    function disableUI(disabled=true){
      [$a1,$a2,$b1,$b2,$check,$hintBtn,$skip].forEach(el=> el.disabled = disabled);
    }

    function startTimer() {
      stopTimer();
      startTs = performance.now();
      tickHandle = setInterval(() => {
        elapsedMs = performance.now() - startTs + penaltyMs;
        $timer.textContent = formatMs(elapsedMs);
      }, 100);
    }
    function stopTimer() { if (tickHandle) { clearInterval(tickHandle); tickHandle = null; } }
    function formatMs(ms) {
      const t = Math.floor(ms);
      const m = Math.floor(t/60000);
      const s = Math.floor((t%60000)/1000);
      const d = Math.floor((t%1000)/100);
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${d}`;
    }

    function phrasesFromInputs() {
      const p1 = [($a1.value||''), ($a2.value||'')];
      const p2 = [($b1.value||''), ($b2.value||'')];
      if (!p1[0].trim() || !p1[1].trim() || !p2[0].trim() || !p2[1].trim()) return null;
      return [p1, p2];
    }

    function checkAnswer() {
      const p = PUZZLES[ix];
      const typed = phrasesFromInputs();
      if (!typed) { setStatus("Please fill out all four words.", "bad"); return; }
      const [t1,t2] = typed; const A = p.answers;
      const ok = (phraseEqual(t1,A[0]) && phraseEqual(t2,A[1])) || (phraseEqual(t1,A[1]) && phraseEqual(t2,A[0]));
      if (ok) { stopTimer(); setStatus(`Correct! Time: ${formatMs(elapsedMs)} — Great job.`, "ok"); }
      else { setStatus("Not quite—keep trying!", "bad"); }
    }

    function useHint() {
      const p = PUZZLES[ix];
      const shown = $hint.dataset.n ? parseInt($hint.dataset.n,10) : 0;
      if (shown < p.hints.length) {
        $hint.textContent = p.hints.slice(0, shown+1).join("  •  ");
        $hint.dataset.n = String(shown+1);
        penaltyMs += 10000; // +10s per hint
      } else {
        $hint.textContent = "No more hints.";
      }
    }

    function loadPuzzleByIndex(index){
      ix = index;
      const p = PUZZLES[ix];
      $num.textContent = `#${ix+1}/${PUZZLES.length}`;
      [$a1,$a2,$b1,$b2].forEach(el => el.value = "");
      $status.textContent = ""; $status.className = "status"; $hint.textContent = ""; $hint.dataset.n = "0"; penaltyMs = 0;
      disableUI(true);
      const img = new Image();
      img.onload = () => {
        // Dynamically size container height to preserve big/tall images nicely
        const naturalAR = img.naturalWidth / img.naturalHeight;
        const wrap = document.querySelector('.wrap');
        const stage = document.querySelector('.imgbox');
        const maxW = wrap.getBoundingClientRect().width - 2; // minus borders
        const maxH = Math.min(window.innerHeight * 0.7, 800); // cap huge desktops
        // Compute fit like CSS contain but we also set an explicit stage height for stable layout
        let targetH = maxW / naturalAR;        // height if constrained by width
        if (targetH > maxH) targetH = maxH;    // constrain overly tall images
        stage.style.height = targetH + 'px';
        $img.src = p.img; 
        disableUI(false); 
        $a1.focus(); 
        startTimer(); 
      };
      img.onerror = () => { 
        const stage = document.querySelector('.imgbox');
        stage.style.height = 'auto';
        setStatus("Image failed to load. Check the path in puzzles.json.", "bad"); 
        disableUI(false); 
      };
      img.src = p.img;
    }

    function nextPuzzle() { loadPuzzleByIndex((ix + 1) % PUZZLES.length); }

    async function boot(){
      disableUI(true);
      setStatus("Loading today\'s puzzle…", "");
      try {
        const res = await fetch('puzzles.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!Array.isArray(data)) throw new Error('JSON root must be an array');
        const cleaned = data.filter(isPuzzle);
        if (cleaned.length === 0) throw new Error('No valid puzzles found');
        PUZZLES = cleaned;
      } catch (e){
        console.warn('Using fallback puzzles because fetch failed:', e);
        setStatus("Using fallback puzzles (add /puzzles.json to control daily puzzles).", "");
      }
      const idx = selectDailyIndex(PUZZLES.length, new Date());
      loadPuzzleByIndex(idx);
    }

    // Events
    $check.addEventListener("click", checkAnswer);
    $hintBtn.addEventListener("click", useHint);
    $skip.addEventListener("click", nextPuzzle);
    [$a1,$a2,$b1,$b2].forEach(el => el.addEventListener("keydown", e => { if (e.key === "Enter") checkAnswer(); }));

    // Start
    window.addEventListener('resize', () => {
      // Recompute stage height on resize for current image
      const p = PUZZLES[ix];
      if (!$img.src) return;
      const img = new Image();
      img.onload = () => {
        const naturalAR = img.naturalWidth / img.naturalHeight;
        const wrap = document.querySelector('.wrap');
        const stage = document.querySelector('.imgbox');
        const maxW = wrap.getBoundingClientRect().width - 2;
        const maxH = Math.min(window.innerHeight * 0.7, 800);
        let targetH = maxW / naturalAR;
        if (targetH > maxH) targetH = maxH;
        stage.style.height = targetH + 'px';
      };
      img.src = p.img;
    });
    boot();
  </script>
</body>
</html>
